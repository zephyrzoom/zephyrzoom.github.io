---
layout: post
title: Javascript
date: 2016-08-06 20:12:00 +0800
---

### 作用域

作用域是引擎执行中寻找变量的区域。

JS使用JIT的编译方式，如：`var a = 2;`，编译器时只会处理声明`var a;`，当执行时才会处理赋值`a = 2;`。

引擎在执行代码时会不停地寻找左值(LHS)与右值(RHS)，先在最近的作用域寻找，找不到再到外层作用域，直到找到。

```javascript
function foo(a) {
    console.log(a + b);
    b = a;
}
foo(2);
```
这段代码中LHS有：`a = ...`(调用函数时隐含的)，`b = ..`，RHS有：`foo(..`，`console`，
`a + ..`，`.. + b`，`.. = a`。左值右值不只是在等号左右的值。函数的定义并没有进行赋值，
只是在调用时才会用到的代码块。

这段代码执行`a + b`时，引擎在查找右值b时，首先在`foo`函数作用域中找，没有找到，再到全局查找，
依然没有，这时会抛出ReferenceError异常。而如果是`b = a`的左值b时，当全局也没找到时，
会创建一个全局变量b。但是，如果在`strict mode`下执行则也会产生ReferenceError异常。

### 词法作用域

词法作用域是在编码时就确定下来的，其作用是为了在作用域内查找特定标识符。

```javascript
function foo(a) {
    var b = a * 2;
    function bar(c) {
        console.log( a, b, c );
    }
    bar(b * 3);
}
foo( 2 );
```
首先假设函数定义确定一个作用域，那么上面的代码定义了3个词法作用域：全局作用域、`foo`作用域和`bar`作用域。
函数的参数也是属于该函数内作用域的，如在查找`console.log(a, b, c)`的标识符`a`时，首先在最内层`bar`作用域
寻找，没找到再到外层作用域，直到在`foo`中找到。这个过程是由内向外的一个冒泡过程，一旦找到就不会再往外层寻找。
但是，有方法可以直接访问到全局变量，`window`是一个全局对象，通过`window.a`就可以忽略冒泡过程，直接访问到`a`。

有两种方法可以破坏这种编码定义下来的词法作用域，`eval`和`with`，`with`不要使用，`eval`不到万不得已不要使用。

`eval`可以执行一段代码，代码中如果有变量的操作，可能会覆盖掉外层的变量。
`with`可用来简化对象赋值，也有同样的效果。

```javascript
function foo(obj) {
    with (obj) {
        a = 2;
        b = 2;
    }
}
var o = {
    a: 3
};
foo( o );
console.log( o.a );
```
上面的代码`with`覆盖掉了`o.a`的值，他在寻找标识符时先从对象`o`内部开始，没找到`b`，再在全局寻找，
依然没有就会创建一个全局变量`a`。

不应使用这两个方法的原因不止这些，关键是会降低程序执行的性能。引擎在运行代码前会先进行词法分析确定标识符的作用域，
而这两个方法导致无法确定其中标识符的作用域范围，还需要在运行时重新编译，因此导致代码执行性能下降。
